#![doc = include_str!("../README.md")]

// Needed for the roto macros
extern crate self as roto;

mod ast;

#[cfg(feature = "cli")]
mod cli;
mod codegen;
mod file_tree;
#[cfg(test)]
mod file_tree_tests;
mod ir_printer;
mod label;
mod lir;
mod mir;
mod module;
pub(crate) mod parser;
mod pipeline;
mod runtime;
pub mod tools;
mod typechecker;

#[cfg(feature = "cli")]
pub use cli::cli;

#[cfg(test)]
pub(crate) use pipeline::{source_file, src};

pub use codegen::TypedFunc;
pub use file_tree::{FileSpec, FileTree, SourceFile};
pub use pipeline::{Package, RotoError, RotoReport};
pub use roto_macros::{
    roto_function, roto_method, roto_static_method, Context,
};
pub use runtime::{
    context::Context,
    func::RegisterableFn,
    items::{Constant, Function, Impl, Item, Library, Module, Type, Use},
    ty::Reflect,
    val::Val,
    verdict::Verdict,
    Runtime,
};

/// Create a list of items to be registered.
///
/// This macro evaluates to [`Library`], which can be passed to
/// [`Runtime::from_lib`] and [`Runtime::add`] to be registered.
///
/// This macro automates some of the boilerplate around registering items, such
/// as adding documentation comments and extracting the names and parameter
/// names of functions. Within functions, all regular Rust syntax is accepted.
///
/// Documentation comments can be added to any of the items. These will be stored and
/// added to the documentation generated by Roto.
///
/// # Syntax
///
/// ## Types
///
/// ```rust,ignore
/// /// A `Clone` type `Val<Foo>` registered as `Foo`
/// clone type Foo = Val<Foo>;
///
/// /// A `Copy` type `Val<Foo>` registered as `Foo`
/// copy type Foo = Val<Foo>;
/// ```
///
/// ## Functions
///
/// ```rust,ignore
/// /// A function
/// fn foo(a: i32, b: Val<Foo>) -> Val<Bar> {
///     todo!()
/// }
///
/// /// A closure
/// let foo = |a: i32, b: Val<Foo>| -> Val<Bar> {
///     todo!()
/// }
///
/// /// A closure with `move`
/// let foo = move |a: i32, b: Val<Foo>| -> Val<Bar> {
///     todo!()
/// }
/// ```
///
/// ## Constants
///
/// ```rust,ignore
/// /// A constant `BAR` of type `Val<Foo>`
/// const BAR: Val<Foo> = todo!();
/// ```
///
/// ## Modules
///
/// ```rust,ignore
/// /// Make a new module with some items
/// mod foo {
///     // Add items here (with the same syntax)
/// }
///
/// /// A module created from a Library
/// mod foo = some_library;
/// ```
///
/// ## Impl blocks
///
/// ```rust,ignore
/// /// Add (static) methods to the `Val<Foo>`
/// ///
/// /// Note that you have to use the Rust type, not the Roto name.
/// impl Val<Foo> {
///     // Add items here (with the same syntax)
/// }
///
/// impl Val<Foo> = some_item_list;
/// ```
///
/// ## Use
///
/// Note that renaming items is not supported yet.
///
/// ```rust,ignore
/// /// Add imports, note that this uses Roto names for types
/// use Option::{Some, None};
/// ```
///
/// ## Including other library items
///
/// ```rust,ignore
/// /// Include some registerable
/// item some_registerable;
/// ```
pub use roto_macros::library;

/// Items exported only for use in macros
pub mod __internal {
    pub use crate::runtime::context::ContextField;
}

pub(crate) const FIND_HELP: &str = "\n\
    If you are seeing this error you have found a bug in the Roto compiler.\n\
    Please open an issue at https://github.com/NLnetLabs/roto.";

/// Panic with an internal compiler error
///
/// Calling this macro instead of [`panic!`] signals a bug in the compiler
macro_rules! ice {
    () => {
        panic!("Internal compiler error{}", $crate::FIND_HELP)
    };
    ($s:literal) => {
        panic!("Internal compiler error: {}{}", format!($s), $crate::FIND_HELP)
    };
    ($s:literal, $($t:tt)*) => {
        panic!("Internal compiler error: {}{}", format!($s, $($t)*), $crate::FIND_HELP)
    }
}

pub(crate) use ice;

/// A source file location
///
/// Generally constructed with the [`location!`] macro.
#[derive(Debug, Clone)]
pub struct Location {
    pub file: &'static str,
    pub line: u32,
    pub column: u32,
}

impl std::fmt::Display for Location {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        format!("{}:{}:{}", self.file, self.line, self.column).fmt(f)
    }
}

/// Rust source code location
#[macro_export]
macro_rules! location {
    () => {
        $crate::Location {
            file: file!(),
            line: line!(),
            column: column!(),
        }
    };
}
